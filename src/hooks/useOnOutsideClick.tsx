import React, {useEffect, useCallback, useMemo} from 'react'

export type TouchOrMouseEvent = MouseEvent | TouchEvent

export type UseOnOutsideClickSettings = {
  containerRef: React.RefObject<HTMLDivElement>
  ignoreClickRefs?: React.RefObject<HTMLElement>[]
  onClickOutside: (e: TouchOrMouseEvent) => void
}

type ShouldCallClickHandlerSettings = {
  ignoreClickRefs?: React.RefObject<HTMLElement>[]
  containerRef: React.RefObject<HTMLDivElement>
  e: TouchOrMouseEvent
}

type ClickOutsideEventHandler = (e: MouseEvent) => boolean
const handlers: ClickOutsideEventHandler[] = []

/**
 * Calls all handlers in reverse order
 * @param event The MouseEvent generated by the click event.
 */
function handleClick(event: MouseEvent) {
  if (!event.defaultPrevented) {
    for (let i = handlers.length - 1; i >= 0; i--) {
      const wasClickOutside = handlers[i](event)
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      if (!wasClickOutside || event.defaultPrevented) {
        break
      }
    }
  }
}

const shouldCallClickHandler = ({ignoreClickRefs, containerRef, e}: ShouldCallClickHandlerSettings): boolean => {
  let shouldCallHandler = true

  // don't call click handler if the mouse event was triggered by an auxiliary button (right click/wheel button/etc)
  if (e instanceof MouseEvent && e.button > 0) {
    shouldCallHandler = false
  }

  // don't call handler if the click happened inside of the container
  if (containerRef.current?.contains(e.target as Node)) {
    shouldCallHandler = false
    // don't call handler if click happened on an ignored ref
  } else if (ignoreClickRefs) {
    for (const ignoreRef of ignoreClickRefs) {
      if (ignoreRef.current?.contains(e.target as Node)) {
        shouldCallHandler = false
        // if we encounter one, break early, we don't need to go through the rest
        break
      }
    }
  }
  return shouldCallHandler
}
// eslint-disable-next-line @typescript-eslint/ban-types
const handlersByToken = new WeakMap<object, ClickOutsideEventHandler>()

export const useOnOutsideClick = ({containerRef, ignoreClickRefs, onClickOutside}: UseOnOutsideClickSettings): void => {
  const handlerToken = useMemo(() => ({}), [])
  const propSpecificHandler = useCallback(
    (e: TouchOrMouseEvent) => {
      const wasClickOutside = shouldCallClickHandler({ignoreClickRefs, containerRef, e})
      if (wasClickOutside) {
        onClickOutside(e)
      }
      return wasClickOutside
    },
    [onClickOutside, containerRef, ignoreClickRefs]
  )
  handlersByToken.set(handlerToken, propSpecificHandler)

  const distinctHandler = useCallback(
    (event: MouseEvent) => {
      const handler = handlersByToken.get(handlerToken)

      if (!handler) {
        return false
      }

      return handler(event)
    },
    [handlerToken]
  )

  useEffect(() => {
    if (handlers.length === 0) {
      // use capture to ensure we get all events
      document.addEventListener('mousedown', handleClick, {capture: true})
    }
    handlers.push(distinctHandler)
    return () => {
      handlers.splice(
        handlers.findIndex(h => h === distinctHandler),
        1
      )
      if (handlers.length === 0) {
        document.removeEventListener('mousedown', handleClick, {capture: true})
      }
    }
  }, [distinctHandler])
}
